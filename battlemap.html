<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The DM's Toolbox: Battle Map</title>

  <!-- Vendor CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.3/font/bootstrap-icons.css" />

  <!-- Site CSS -->
  <link href="/css/site.css" rel="stylesheet" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/images/dndFavicon (2).png" />

  <!-- Vendor JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script src="/js/site.js"></script>

  <style>
    :root {
      --bg:#0b0f14; --panel:#0f1620; --ink:#e6f1ff; --muted:#8fa3bf;
      --accent:#8bd3ff; --line:#1b2430; --nav:56px;
    }
    html, body { height: 100%; background: var(--bg); }
    body { margin: 0; color: var(--ink); padding-top: var(--nav); }
    .navbar { height: var(--nav); background:#0f1620; border-bottom:1px solid var(--line) }

    /* Layout */
    .map-wrap{
      min-height: calc(100dvh - var(--nav));
      display: flex;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      overflow-x: hidden; /* kill horizontal page scroll */
    }

    /* Offcanvas controls: drawer on mobile, static column on lg+ */
    #controlsDrawer.offcanvas-lg { width: 340px; max-width: 40vw; }
    @media (min-width: 992px){
      #controlsDrawer.offcanvas-lg{
        position: static;
        transform: none !important;
        visibility: visible !important;
        background: transparent;
        border: none;
      }
      #controlsDrawer .offcanvas-header { display: none !important; }
      #controlsDrawer .offcanvas-body { padding: 0 !important; }
    }

    /* Make controls wider on mobile */
    @media (max-width: 991.98px) {
      #controlsDrawer.offcanvas-lg {
        width: 90vw;       /* take up most of the viewport width */
        max-width: 480px;  /* optional cap for tablets */
      }
    }

    .panel { background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 12px; overflow: auto; }
    .panel h2 { margin: 0 0 8px; font-size: 16px; letter-spacing: .3px; }
    .group h3 { margin: 0 0 8px; font-size: 13px; color: var(--muted); font-weight: 600; }
    label { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 6px 0; font-size: 13px; color: var(--ink); }
    input[type="number"], input[type="text"], input[type="color"], select {
      background: #0a111a; border: 1px solid var(--line); color: var(--ink);
      padding: 6px 8px; border-radius: 8px; font-size: 13px;
    }
    input[type="file"] { font-size: 12px; }
    button { background: #0a111a; color: var(--ink); border: 1px solid var(--line); padding: 8px 10px; border-radius: 10px; cursor: pointer; font-size: 13px; }
    button:hover { border-color: #283345; }
    .row-inline { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 12px; }

    .canvas-panel { flex: 1 1 auto; min-width: 0; display:flex; flex-direction: column; min-height: 0; }
    .bar { padding: 8px 10px; display:flex; align-items:center; gap:8px; border: 1px solid var(--line); border-radius: 12px; background: #0c131d; margin-bottom: 12px; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-wrap: wrap; }
    .bar span { font-size:12px; color: var(--muted); }
    .bar .active { outline: 2px solid var(--accent); }

    .canvas-wrap { position: relative; flex: 1 1 auto; min-height: 0; }
    canvas { display:block; width: 100%; height: 100%; background: #0a0f16; border: 1px solid var(--line); border-radius: 12px; cursor: grab; touch-action: none; }
    canvas.dragging { cursor: grabbing; }
    .token-list { display:flex; flex-wrap: wrap; gap:6px; }
    .pill { border:1px solid var(--line); padding:4px 8px; border-radius:999px; font-size:12px; background:#0a111a; }

    .context-menu { position:absolute; background:#0f1620; border:1px solid var(--line); border-radius:8px; padding:6px; z-index:1000; display:none; min-width:160px; }
    .context-menu button { width:100%; text-align:left; padding:6px 8px; border-radius:6px; }

    .measure-label { position:absolute; background:#0f1620; border:1px solid var(--line); border-radius:6px; padding:2px 6px; font-size:12px; color:var(--ink); transform:translate(-50%, -150%); pointer-events:none; }

    /* Mobile touch targets */
    @media (max-width: 991.98px){
      input, select, button { min-height: 44px; }
      label { grid-template-columns: 1fr; gap: 4px; }
      .row-inline { gap: 6px; }
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark fixed-top" id="mainNav">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">
        <img src="/images/dndFavicon (2).png" height="32" width="32" alt="App Logo" class="d-inline-block me-1" />
        The DM's Toolbox
      </a>

      <!-- Mobile Controls button -->
      <button class="btn btn-outline-light d-lg-none ms-auto"
              type="button"
              data-bs-toggle="offcanvas"
              data-bs-target="#controlsDrawer"
              aria-controls="controlsDrawer">
        <i class="bi bi-sliders"></i> Controls
      </button>

      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
              aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ms-auto ms-lg-3 mb-2 mb-lg-0">
          <li class="nav-item"><a class="nav-link" href="index.html">Initiative</a></li>
          <li class="nav-item"><a class="nav-link" href="name.html">Name Gen</a></li>
          <li class="nav-item"><a class="nav-link" href="loot.html">Loot Gen</a></li>
          <li class="nav-item"><a class="nav-link" href="shop.html">Shop Gen</a></li>
          <li class="nav-item"><a class="nav-link" href="npc.html">NPC Gen</a></li>
          <li class="nav-item"><a class="nav-link" href="tav.html">Tavern/Inn Gen</a></li>
          <li class="nav-item"><a class="nav-link active" aria-current="page" href="battlemap.html">Battle Map</a></li>
          <li class="nav-item"><a class="nav-link" href="encounterbuilder.html">Encounter Builder</a></li>
          <li class="nav-item"><a class="nav-link" href="characters.html">Characters</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="map-wrap">
    <!-- Controls: offcanvas on <lg, static column on ≥lg -->
    <aside id="controlsDrawer"
           class="offcanvas offcanvas-lg offcanvas-start panel"
           tabindex="-1"
           aria-labelledby="controlsLabel"
           data-bs-scroll="true"
           data-bs-backdrop="false">
      <div class="offcanvas-header d-lg-none">
        <h5 id="controlsLabel" class="m-0">Battle Map Controls</h5>
        <button type="button" class="btn-close btn-close-white"
        data-bs-dismiss="offcanvas" aria-label="Close"></button>
      </div>

      <div class="offcanvas-body p-2 p-lg-0">

        <!-- DESKTOP/LARGE: Accordion groups -->
        <div class="accordion" id="bmAccordion">

          <!-- Map & Grid -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="accMapHdr">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#accMap" aria-expanded="true">
                1) Map & Grid
              </button>
            </h2>
            <div id="accMap" class="accordion-collapse collapse show" data-bs-parent="#bmAccordion">
              <div class="accordion-body">
                <div class="group">
                  <h3>Map</h3>
                  <label>Upload Map <input id="mapFile" type="file" accept="image/*" /></label>
                  <label>Base Scale (px per cell) <input id="gridSize" type="number" min="4" max="256" value="140" /></label>
                  <label>Units per cell <input id="unitsPerCell" type="number" min="1" value="5" /></label>
                  <label>Grid Color <input id="gridColor" type="color" value="#6aa5ff" /></label>
                  <label>Grid Opacity <input id="gridAlpha" type="number" min="0" max="1" step="0.05" value="0.35" /></label>
                  <label>Show Grid <input id="showGrid" type="checkbox" checked /></label>
                  <div class="row-inline">
                    <button id="centerMap">Center</button>
                    <button id="fitMap">Fit</button>
                    <button id="clearMap">Clear</button>
                  </div>
                </div>
                <hr class="text-secondary"/>
                <div class="group">
                  <h3>Map Transform</h3>
                  <label>Map Scale (%) <input id="mapScale" type="number" min="10" max="400" step="1" value="100" /></label>
                  <label>Map Offset X (px) <input id="mapOffsetX" type="number" step="1" value="0" /></label>
                  <label>Map Offset Y (px) <input id="mapOffsetY" type="number" step="1" value="0" /></label>
                  <div class="row-inline">
                    <button id="resetMapTransform">Reset Map Transform</button>
                  </div>
                </div>
                <hr class="text-secondary"/>
                <div class="group">
                  <h3>Grid Alignment</h3>
                  <label>Grid Origin X (px) <input id="gridOffsetX" type="number" step="1" value="0" /></label>
                  <label>Grid Origin Y (px) <input id="gridOffsetY" type="number" step="1" value="0" /></label>
                  <div class="row-inline">
                    <button id="pickGridOrigin">Pick Origin on Map</button>
                    <button id="snapOriginToMap">Align to Clicked Intersection</button>
                  </div>
                  <label>Calibrate: cells between clicks <input id="calibCells" type="number" min="1" step="1" value="10" /></label>
                  <div class="row-inline">
                    <button id="startCalibrate">Start Calibration</button>
                    <span class="muted" id="calibStatus"></span>
                  </div>
                  <div class="muted">Use calibration when the image has a printed grid or unknown DPI: click two intersections N cells apart.</div>
                  <div class="muted">Wheel to zoom. Middle-drag or hold <kbd>Space</kbd> + drag to pan.</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Tokens & Presets -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="accTokensHdr">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#accTokens">
                2) Tokens & Presets
              </button>
            </h2>
            <div id="accTokens" class="accordion-collapse collapse" data-bs-parent="#bmAccordion">
              <div class="accordion-body">
                <div class="group">
                  <h3>Tokens</h3>
                  <label>Upload Token Image <input id="tokenFile" type="file" accept="image/*" /></label>
                  <label>Name <input id="tokenName" type="text" placeholder="Goblin A" /></label>
                  <div class="row-inline">
                    <button id="addToken">Add Token</button>
                    <button id="deleteSelected">Delete Selected</button>
                  </div>
                  <label>Snap to Grid <input id="snap" type="checkbox" checked /></label>
                  <label>Token Size (cells) <input id="tokenCells" type="number" min="0.5" step="0.5" value="1" /></label>
                </div>

                <hr class="text-secondary"/>
                <div class="group">
                  <h3>Presets</h3>
                  <label>Choose Preset
                    <select id="tokenPreset" style="min-width:220px">
                      <option value="">— select a token —</option>
                    </select>
                  </label>
                  <div class="row-inline">
                    <button id="addPreset">Add Selected Preset</button>
                  </div>
                  <div class="token-list" id="tokenList"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Session -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="accSessionHdr">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#accSession">
                3) Session
              </button>
            </h2>
            <div id="accSession" class="accordion-collapse collapse" data-bs-parent="#bmAccordion">
              <div class="accordion-body">
                <div class="group">
                  <div class="row-inline">
                    <button id="exportJson">Export JSON</button>
                    <input id="importJsonFile" type="file" accept="application/json" />
                  </div>
                  <div class="row-inline">
                    <button id="resetAll" title="Clear map and tokens">Reset</button>
                  </div>
                  <div class="muted">State saves to localStorage automatically.</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Shortcuts -->
          <div class="accordion-item">
            <h2 class="accordion-header" id="accShortHdr">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#accShort">
                Shortcuts
              </button>
            </h2>
            <div id="accShort" class="accordion-collapse collapse" data-bs-parent="#bmAccordion">
              <div class="accordion-body">
                <div class="muted">
                  Space+Drag: Pan • Wheel: Zoom • <strong>Brush Mode: Paint Fog</strong> (or Shift+Drag on desktop)
                  • Measure: toggle button (or Alt on desktop) • R: Rotate • +/-: Resize • [ ]: Send/Bring • Esc: Clear selection • Del: Delete
                </div>
              </div>
            </div>
          </div>

        </div>
        <!-- /accordion -->
      </div>
    </aside>

    <!-- Canvas column -->
    <section class="canvas-panel">
      <div class="bar">
        <button id="toggleFog">Fog: Off</button>
        <button id="fogReveal" disabled>Reveal</button>
        <button id="fogCover" disabled>Cover</button>
        <label class="ms-2">Brush
          <input id="fogBrush" type="number" min="5" max="400" step="5" value="80" style="width:90px" disabled>
        </label>
        <button id="fogClear" disabled>Clear Fog</button>

        <!-- NEW: Mobile-friendly mode toggles -->
        <button id="fogBrushMode" aria-pressed="false" title="Toggle brush mode for touch/mobile">Brush Mode</button>
        <button id="measureToggle" aria-pressed="false" title="Toggle measure mode (mobile-friendly)">Measure</button>

        <span id="status" class="ms-2">Ready</span>
      </div>

      <div class="canvas-wrap">
        <canvas id="stage" width="1920" height="1080"></canvas>
        <div id="measureLabel" class="measure-label" style="display:none;">0 ft</div>
        <div id="ctxMenu" class="context-menu">
          <button data-cmd="rename">Rename</button>
          <button data-cmd="duplicate">Duplicate</button>
          <button data-cmd="bring">Bring Forward</button>
          <button data-cmd="send">Send Backward</button>
          <button data-cmd="delete">Delete</button>
        </div>
      </div>
    </section>
  </div>

  <footer class="container-fluid site-footer" role="contentinfo"
          style="background:#0f1620;border-top:1px solid var(--line);position:fixed;left:0;right:0;bottom:0;display:none"></footer>

<script>
(function(){
  // --- Built-in manifest; /images/tokenManifest.json (if present) overrides.
  const DEFAULT_MANIFEST = {
    players: [
      { name: 'Artificer',    src: '/images/playerTokens/PlayerArtificerToken.png' },
      { name: 'Barbarian',    src: '/images/playerTokens/PlayerBarbarianToken.png' },
      { name: 'Bard',         src: '/images/playerTokens/PlayerBardToken.png' },
      { name: 'Blood Hunter', src: '/images/playerTokens/PlayerBloodHunterToken.png' },
      { name: 'Cleric',       src: '/images/playerTokens/PlayerClericToken.png' },
      { name: 'Druid',        src: '/images/playerTokens/PlayerDruidToken.png' },
      { name: 'Fighter',      src: '/images/playerTokens/PlayerFighterToken.png' },
      { name: 'Monk',         src: '/images/playerTokens/PlayerMonkToken.png' },
      { name: 'Paladin',      src: '/images/playerTokens/PlayerPaladinToken.png' },
      { name: 'Ranger',       src: '/images/playerTokens/PlayerRangerToken.png' },
      { name: 'Rogue',        src: '/images/playerTokens/PlayerRogueToken.png' },
      { name: 'Sorcerer',     src: '/images/playerTokens/PlayerSorcererToken.png' },
      { name: 'Warlock',      src: '/images/playerTokens/PlayerWarlockToken.png' },
      { name: 'Wizard',       src: '/images/playerTokens/PlayerWizardToken.png' }
    ],
    enemies: [
      { name: 'Aberration',   src: '/images/enemyTokens/EnemyAberationToken.png' },
      { name: 'Beast',        src: '/images/enemyTokens/EnemyBeastToken.png' },
      { name: 'Celestial',    src: '/images/enemyTokens/EnemyCelestialToken.png' },
      { name: 'Construct',    src: '/images/enemyTokens/EnemyConstructToken.png' },
      { name: 'Dragon',       src: '/images/enemyTokens/EnemyDragonToken.png' },
      { name: 'Elemental',    src: '/images/enemyTokens/EnemyElementalToken.png' },
      { name: 'Fey',          src: '/images/enemyTokens/EnemyFeyToken.png' },
      { name: 'Fiend',        src: '/images/enemyTokens/EnemyFiendToken.png' },
      { name: 'Giant',        src: '/images/enemyTokens/EnemyGiantToken.png' },
      { name: 'Humanoid',     src: '/images/enemyTokens/EnemyHumanoidToken.png' },
      { name: 'Monstrosity',  src: '/images/enemyTokens/EnemyMonstrosityToken.png' },
      { name: 'Ooze',         src: '/images/enemyTokens/EnemyOozeToken.png' },
      { name: 'Plant',        src: '/images/enemyTokens/EnemyPlantToken.png' },
      { name: 'Undead',       src: '/images/enemyTokens/EnemyUndeadToken.png' }
    ]
  };

  async function loadTokenManifest(){
    return Promise.resolve(DEFAULT_MANIFEST);
  }

  function buildPresetDropdown(manifest){
    tokenPresetEl.innerHTML = '<option value="">— select a token —</option>';
    const addGroup = (label, list) => {
      const og = document.createElement('optgroup');
      og.label = label;
      (list || []).forEach(it => {
        const opt = document.createElement('option');
        opt.value = it.src;
        opt.dataset.name = it.name;
        opt.textContent = it.name;
        og.appendChild(opt);
      });
      tokenPresetEl.appendChild(og);
    };
    addGroup('Players', manifest.players);
    addGroup('Enemies', manifest.enemies);
  }

  const imageCache = new Map();
  function getCachedImage(src){
    if(imageCache.has(src)) return Promise.resolve(imageCache.get(src));
    return loadImage(src).then(img=>{ imageCache.set(src,img); return img; });
  }

  /** @typedef {{ id:string, name:string, imgSrc:string, img:HTMLImageElement|null, x:number, y:number, w:number, h:number, rot:number, selected?:boolean }} Token */

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha: false });
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const W = Math.max(200, Math.round(rect.width * DPR));
    const H = Math.max(200, Math.round(rect.height * DPR));
    if (canvas.width !== W || canvas.height !== H) {
      canvas.width = W;
      canvas.height = H;
    }
  }
  new ResizeObserver(resizeCanvas).observe(canvas);
  resizeCanvas();

  const statusEl = document.getElementById('status');
  const tokenListEl = document.getElementById('tokenList');
  const tokenPresetEl = document.getElementById('tokenPreset');
  const ctxMenu = document.getElementById('ctxMenu');
  const measureLabel = document.getElementById('measureLabel');

  // --- State
  const state = {
    map: { imgSrc: '', img: null, w: 0, h: 0 },
    mapTransform: { scale: 1, x: 0, y: 0 }, // image->world transform
    grid: { size: 50, unitsPerCell: 5, color: '#6aa5ff', alpha: 0.35, show: true, offsetX: 0, offsetY: 0 },
    view: { x: 0, y: 0, scale: 1 },         // world->screen
    tokens: /** @type{Token[]} */([]),
    ui: {
      dragMode: 'none', dragId: null, dragOffset:{x:0,y:0},
      spaceDown:false, tool: 'none',
      calib:{p1:null,p2:null},
      measuring:false, measureStart:null,
      brushMode:false,        // NEW: mobile fog brush
      measureToggle:false     // NEW: mobile measure
    }
  };

  // --- Fog of War layer (image-space bitmap, aligns with map image)
  const fog = document.createElement('canvas');
  const fctx = fog.getContext('2d', { alpha:true });
  const fogState = { enabled:false, brush:80, mode:'reveal', painting:false };

  function setFogUI(enabled) {
    document.getElementById('toggleFog').textContent = enabled ? 'Fog: On' : 'Fog: Off';
    ['fogReveal','fogCover','fogBrush','fogClear'].forEach(id=>{
      document.getElementById(id).disabled = !enabled;
    });
    document.getElementById('fogReveal').classList.toggle('active', enabled && fogState.mode==='reveal');
    document.getElementById('fogCover').classList.toggle('active', enabled && fogState.mode==='cover');
  }

  function ensureFogSize() {
    const W = state.map?.w || 0;
    const H = state.map?.h || 0;
    if (!W || !H) { fog.width = 1; fog.height = 1; return; }
    if (fog.width !== W || fog.height !== H) {
      // preserve existing if possible
      const old = document.createElement('canvas');
      old.width = fog.width; old.height = fog.height;
      old.getContext('2d').drawImage(fog,0,0);
      fog.width = W; fog.height = H;
      fctx.clearRect(0,0,fog.width,fog.height);
      fctx.drawImage(old,0,0);
    }
  }

  // image<->world<->screen conversions
  function imageToWorld(ix, iy){
    const s = state.mapTransform.scale;
    return { x: ix * s + state.mapTransform.x, y: iy * s + state.mapTransform.y };
  }
  function worldToImage(wx, wy){
    const s = state.mapTransform.scale || 1;
    return { x: (wx - state.mapTransform.x) / s, y: (wy - state.mapTransform.y) / s };
  }
  function worldToScreen(x,y){ return { x: (x*state.view.scale + state.view.x), y: (y*state.view.scale + state.view.y) }; }
  function screenToWorld(x,y){ return { x: (x - state.view.x)/state.view.scale, y: (y - state.view.y)/state.view.scale }; }

  const STORAGE_KEY = 'dmtoolbox.battlemap.mvp.v3';
function save(){
  // Always capture the fog canvas if it exists, regardless of enabled flag
  const fogData = (fog.width > 1 && fog.height > 1) ? tryCanvasToDataURL(fog) : null;

  const payload = {
    map: { imgSrc: state.map.imgSrc, w: state.map.w, h: state.map.h },
    mapTransform: state.mapTransform,
    grid: state.grid,
    view: state.view,
    tokens: state.tokens.map(t => ({
      id: t.id,
      name: t.name,
      imgSrc: t.imgSrc,
      x: t.x,
      y: t.y,
      w: t.w,
      h: t.h,
      rot: t.rot,
      selected: !!t.selected     
    })),
    fog: fogData,
    fogState: {               
      enabled: fogState.enabled,
      mode: fogState.mode,
      brush: fogState.brush
    }
  };

  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); } catch {}
  }
  function load(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    try {
      const data = JSON.parse(raw);

      Object.assign(state.grid, data.grid || {});
      Object.assign(state.view, data.view || {});
      Object.assign(state.mapTransform, data.mapTransform || {});

      state.tokens = (data.tokens || []).map(t => ({
        ...t,
        img: null,
        selected: !!t.selected,
        rot: typeof t.rot === 'number' ? t.rot : 0
      }));

      // Restore fog settings if present (backward-compatible)
      if (data.fogState) {
        fogState.enabled = !!data.fogState.enabled;
        fogState.mode = data.fogState.mode || fogState.mode;
        fogState.brush = typeof data.fogState.brush === 'number'
          ? data.fogState.brush
          : fogState.brush;
        setFogUI(fogState.enabled);
        document.getElementById('fogBrush').value = fogState.brush;
      }

      if (data.map?.imgSrc) {
        loadImage(data.map.imgSrc).then(img => {
          state.map = {
            imgSrc: data.map.imgSrc,
            img,
            w: img.naturalWidth,
            h: img.naturalHeight
          };
          ensureFogSize();
          if (data.fog) { drawDataUrlToCanvas(data.fog, fog); }
          // IMPORTANT: do NOT call fitMap(); keep saved view/pan/zoom
        });
      }

      state.tokens.forEach(t => {
        loadImage(t.imgSrc).then(img => (t.img = img));
      });
    } catch (e) {
      console.warn('Load failed', e);
    }
  }

  function loadImage(src){ return new Promise((res, rej)=>{ const img = new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=src; }); }
  function tryCanvasToDataURL(cnv){
    try { return cnv.toDataURL('image/webp', 0.85); } catch { try { return cnv.toDataURL('image/png'); } catch { return null; } }
  }
  function drawDataUrlToCanvas(url, cnv){
    return new Promise((resolve)=>{ const img=new Image(); img.onload=()=>{ const ct=cnv.getContext('2d'); ct.clearRect(0,0,cnv.width,cnv.height); ct.drawImage(img,0,0); resolve(); }; img.src=url; });
  }
  function setStatus(text){ statusEl.textContent = text; }

  function draw(){
    const { width:W, height:H } = canvas;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#091018';
    ctx.fillRect(0,0,W,H);

    // world->screen
    ctx.setTransform(state.view.scale, 0, 0, state.view.scale, state.view.x, state.view.y);

    // Map image (image->world)
    if(state.map.img){
      ctx.save();
      ctx.translate(state.mapTransform.x, state.mapTransform.y);
      ctx.scale(state.mapTransform.scale, state.mapTransform.scale);
      ctx.drawImage(state.map.img, 0, 0);
      // Fog in image-space over the map
      if (fogState.enabled && fog.width > 1 && fog.height > 1) {
        ctx.drawImage(fog, 0, 0);
      }
      ctx.restore();
    }

    // Grid (world-space)
    if(state.grid.show){ drawGrid(); }

    // Tokens
    for(const t of state.tokens){
      if(t.img){
        ctx.save();
        const cx = t.x + t.w/2;
        const cy = t.y + t.h/2;
        ctx.translate(cx, cy);
        if (t.rot) ctx.rotate(t.rot);
        ctx.drawImage(t.img, -t.w/2, -t.h/2, t.w, t.h);
        if(t.selected){
          ctx.lineWidth = 2/state.view.scale;
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeRect(-t.w/2, -t.h/2, t.w, t.h);
        }
        ctx.restore();
      }
    }

    // Measuring overlay
    if (state.ui.measuring && state.ui.measureStart) {
      const mp = state.ui.measureStart;
      const rect = canvas.getBoundingClientRect();
      const mx = (mouseScreen.x - rect.left) * DPR;
      const my = (mouseScreen.y - rect.top) * DPR;
      const mWorld = screenToWorld(mx, my);
      const dx = mWorld.x - mp.x;
      const dy = mWorld.y - mp.y;
      const distPx = Math.hypot(dx, dy);
      const cells = distPx / state.grid.size;
      const units = cells * state.grid.unitsPerCell;
      ctx.save();
      ctx.lineWidth = 2 / state.view.scale;
      ctx.strokeStyle = '#8bd3ff';
      ctx.beginPath();
      ctx.moveTo(mp.x, mp.y);
      ctx.lineTo(mWorld.x, mWorld.y);
      ctx.stroke();
      ctx.restore();
      // label
      const mid = worldToScreen((mp.x + mWorld.x)/2, (mp.y + mWorld.y)/2);
      measureLabel.style.left = mid.x + 'px';
      measureLabel.style.top = mid.y + 'px';
      measureLabel.textContent = `${Math.round(units)} ft (${cells.toFixed(2)} cells)`;
      measureLabel.style.display = 'block';
    } else {
      measureLabel.style.display = 'none';
    }

    ctx.setTransform(1,0,0,1,0,0);
    requestAnimationFrame(draw);
  }

  function drawGrid(){
    const { size, color, alpha, offsetX, offsetY } = state.grid;
    const { width:W, height:H } = canvas;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1 / state.view.scale;

    const topLeft = screenToWorld(0,0);
    const botRight = screenToWorld(W,H);

    const xStart = Math.floor((topLeft.x - offsetX) / size) * size + offsetX;
    const xEnd = Math.ceil((botRight.x - offsetX) / size) * size + offsetX;
    const yStart = Math.floor((topLeft.y - offsetY) / size) * size + offsetY;
    const yEnd = Math.ceil((botRight.y - offsetY) / size) * size + offsetY;

    ctx.beginPath();
    for(let x=xStart; x<=xEnd; x+=size){ ctx.moveTo(x, yStart); ctx.lineTo(x, yEnd); }
    for(let y=yStart; y<=yEnd; y+=size){ ctx.moveTo(xStart, y); ctx.lineTo(xEnd, y); }
    ctx.stroke();

    // Major lines every 5 cells
    ctx.lineWidth = 2 / state.view.scale;
    ctx.beginPath();
    const major = size * 5;
    const xMStart = Math.floor((topLeft.x - offsetX) / major) * major + offsetX;
    const xMEnd = Math.ceil((botRight.x - offsetX) / major) * major + offsetX;
    const yMStart = Math.floor((topLeft.y - offsetY) / major) * major + offsetY;
    const yMEnd = Math.ceil((botRight.y - offsetY) / major) * major + offsetY;
    for(let x=xMStart; x<=xMEnd; x+=major){ ctx.moveTo(x, yStart); ctx.lineTo(x, yEnd); }
    for(let y=yMStart; y<=yEnd; y+=major){ ctx.moveTo(xStart, y); ctx.lineTo(xEnd, y); }
    ctx.stroke();
    ctx.restore();
  }

  function centerMap(){
    if(!state.map.img) return;
    const { width:W, height:H } = canvas;
    state.view.x = (W - state.map.w*state.view.scale)/2;
    state.view.y = (H - state.map.h*state.view.scale)/2;
    setStatus('Centered'); save();
  }
  function fitMap(){
    if(!state.map.img) return;
    const { width:W, height:H } = canvas;
    const sx = W / Math.max(1,state.map.w);
    const sy = H / Math.max(1,state.map.h);
    state.view.scale = Math.min(sx, sy) * 0.95;
    centerMap();
  }

  function hitToken(wx, wy){
    // consider rotation by inverse transform
    for(let i=state.tokens.length-1; i>=0; i--){
      const t = state.tokens[i];
      const cx = t.x + t.w/2;
      const cy = t.y + t.h/2;
      const dx = wx - cx, dy = wy - cy;
      const c = Math.cos(-(t.rot||0)), s = Math.sin(-(t.rot||0));
      const rx = dx*c - dy*s, ry = dx*s + dy*c;
      if(Math.abs(rx) <= t.w/2 && Math.abs(ry) <= t.h/2){ return t; }
    }
    return null;
  }

  let isPointerDown = false, pointerId = null, last = { x:0, y:0 };
  let mouseScreen = { x:0, y:0 };

    // Pinch zoom state
  const activePointers = new Map();
  let pinchStartDistance = null;
  let pinchStartScale = null;
  let pinchCenter = null; // world-space point to zoom around

  // Decide whether to paint fog (desktop: Shift, mobile: Brush Mode)
  function wantsFogPaint(ev){
    return fogState.enabled
      && (fogState.mode === 'reveal' || fogState.mode === 'cover')
      && (ev.shiftKey || state.ui.brushMode);
  }

  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);

    // Track all active pointers for pinch
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // If we now have 2 fingers down, start pinch mode
    if (activePointers.size === 2) {
      const [p1, p2] = [...activePointers.values()];
      pinchStartDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      pinchStartScale = state.view.scale;

      // Compute world-space center of the pinch
      const rect = canvas.getBoundingClientRect();
      const centerClientX = (p1.x + p2.x) / 2;
      const centerClientY = (p1.y + p2.y) / 2;
      const sx = (centerClientX - rect.left) * DPR;
      const sy = (centerClientY - rect.top) * DPR;
      pinchCenter = screenToWorld(sx, sy);

      // Cancel any token drag / pan in progress
      state.ui.dragMode = 'none';
      state.ui.dragId = null;
      fogState.painting = false;

      // Do NOT start normal single-pointer behavior when pinch begins
      isPointerDown = false;
      pointerId = null;
      return;
    }

    // Normal single-pointer setup
    pointerId = e.pointerId;
    isPointerDown = true;
    last = { x:e.clientX, y:e.clientY };

    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR;
    const sy = (e.clientY - rect.top) * DPR;
    const wpt = screenToWorld(sx, sy);

    // Mobile/Toggle measuring
    if (state.ui.measureToggle || state.ui.measuring) {
      state.ui.measuring = true;
      state.ui.measureStart = wpt;
      return;
    }

    // Fog paint starts if Shift OR BrushMode
    if (wantsFogPaint(e)) {
      fogState.painting = true;
      const ip = worldToImage(wpt.x, wpt.y);
      fogDot(ip.x, ip.y);
      return;
    }

    // Tools (calibrate/origin)
    if(state.ui.tool === 'calibrate'){
      if(!state.ui.calib.p1){ state.ui.calib.p1 = {x:wpt.x, y:wpt.y}; calibStatusEl.textContent = 'Click second intersection'; }
      else {
        state.ui.calib.p2 = {x:wpt.x, y:wpt.y};
        const dx = state.ui.calib.p2.x - state.ui.calib.p1.x; const dy = state.ui.calib.p2.y - state.ui.calib.p1.y;
        const dist = Math.hypot(dx, dy);
        const cells = Math.max(1, parseFloat(calibCellsEl.value)||10);
        const newSize = dist / cells;
        state.grid.size = clamp(newSize, 4, 256);
        state.grid.offsetX = state.grid.offsetX + (state.ui.calib.p1.x - Math.round((state.ui.calib.p1.x - state.grid.offsetX)/state.grid.size)*state.grid.size);
        state.grid.offsetY = state.grid.offsetY + (state.ui.calib.p1.y - Math.round((state.ui.calib.p1.y - state.grid.offsetY)/state.grid.size)*state.grid.size);
        gridOffsetXEl.value = Math.round(state.grid.offsetX);
        gridOffsetYEl.value = Math.round(state.grid.offsetY);
        state.ui.tool = 'none'; calibStatusEl.textContent = `Calibrated: ${state.grid.size.toFixed(2)} px/cell`; save();
      }
      return;
    }
    if(state.ui.tool === 'pickOrigin'){
      state.grid.offsetX = wpt.x; state.grid.offsetY = wpt.y;
      gridOffsetXEl.value = Math.round(state.grid.offsetX);
      gridOffsetYEl.value = Math.round(state.grid.offsetY);
      state.ui.tool = 'none'; calibStatusEl.textContent = 'Origin set'; save(); return;
    }
    if(state.ui.tool === 'snapOrigin'){
      const size = state.grid.size;
      state.grid.offsetX = wpt.x - Math.round(wpt.x/size)*size;
      state.grid.offsetY = wpt.y - Math.round(wpt.y/size)*size;
      gridOffsetXEl.value = Math.round(state.grid.offsetX);
      gridOffsetYEl.value = Math.round(state.grid.offsetY);
      state.ui.tool = 'none'; calibStatusEl.textContent = 'Aligned to clicked intersection'; save(); return;
    }

    const token = hitToken(wpt.x, wpt.y);
    const panMode = state.ui.spaceDown || e.button === 1;

    if(!panMode && token){
      state.tokens.forEach(t=> t.selected = false);
      token.selected = true;
      state.ui.dragMode = 'token';
      state.ui.dragId = token.id;
      state.ui.dragOffset = { x: wpt.x - token.x, y: wpt.y - token.y };
      hideMenu();
      setStatus(`Dragging ${token.name||'token'}`);
      updateTokenList();
    } else {
      state.tokens.forEach(t=> t.selected = false);
      state.ui.dragMode = 'pan';
      hideMenu();
      setStatus('Panning');
      updateTokenList();
    }
  });

    canvas.addEventListener('pointermove', (e)=>{
    mouseScreen = { x:e.clientX, y:e.clientY };

    // Update position of this pointer if it's part of a pinch
    if (activePointers.has(e.pointerId)) {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }

    // If we have 2 pointers and pinch is active, handle pinch zoom
    if (activePointers.size === 2 && pinchStartDistance) {
      e.preventDefault(); // stop browser gestures

      const [p1, p2] = [...activePointers.values()];
      const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y) || 1;
      const factor = dist / pinchStartDistance;
      const newScale = clamp(pinchStartScale * factor, 0.1, 8);

      // Keep pinchCenter under the same screen position
      const before = worldToScreen(pinchCenter.x, pinchCenter.y);
      state.view.scale = newScale;
      const after = worldToScreen(pinchCenter.x, pinchCenter.y);
      state.view.x += (before.x - after.x);
      state.view.y += (before.y - after.y);

      return; // don't run the normal drag/pan logic
    }

    // Normal single-pointer logic
    if(!isPointerDown || e.pointerId !== pointerId) return;

    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR;
    const sy = (e.clientY - rect.top) * DPR;
    const wpt = screenToWorld(sx, sy);

    // Continue fog paint only if painting
    if (fogState.painting) {
      const ip = worldToImage(wpt.x, wpt.y);
      fogDot(ip.x, ip.y);
      return;
    }

    if(state.ui.measuring) return; // render handles the line

    if(state.ui.dragMode === 'token' && state.ui.dragId){
      const t = state.tokens.find(t=> t.id === state.ui.dragId);
      if(t){ t.x = wpt.x - state.ui.dragOffset.x; t.y = wpt.y - state.ui.dragOffset.y; }
    }
    if(state.ui.dragMode === 'pan'){
      const dx = (e.clientX - last.x) * DPR;
      const dy = (e.clientY - last.y) * DPR;
      state.view.x += dx;
      state.view.y += dy;
      last = { x:e.clientX, y:e.clientY };
    }
  });


    window.addEventListener('pointerup', (e)=>{
    // Remove from activePointers (for pinch tracking)
    activePointers.delete(e.pointerId);
    if (activePointers.size < 2) {
      pinchStartDistance = null;
      pinchStartScale = null;
      pinchCenter = null;
    }

    if(e.pointerId === pointerId){
      isPointerDown = false;
      pointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    }

    if (fogState.painting) {
      fogState.painting = false;
      save();
      return;
    }

    if(state.ui.measuring){
      // If toggle is on, keep measuring until toggled off; otherwise end now.
      if(!state.ui.measureToggle){
        state.ui.measuring = false;
        state.ui.measureStart = null;
      }
      return;
    }

    if(state.ui.dragMode === 'token' && state.ui.dragId){
      const t = state.tokens.find(t=> t.id === state.ui.dragId);
      if(t && document.getElementById('snap').checked){
        const s = state.grid.size;
        t.x = Math.round(t.x / s) * s;
        t.y = Math.round(t.y / s) * s;
      }
    }
    state.ui.dragMode = 'none';
    state.ui.dragId = null;
    save();
    setStatus('Ready');
  });

    window.addEventListener('pointercancel', (e)=>{
    activePointers.delete(e.pointerId);
    if (activePointers.size < 2) {
      pinchStartDistance = null;
      pinchStartScale = null;
      pinchCenter = null;
    }

    if(e.pointerId === pointerId){
      isPointerDown = false;
      pointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    }

    if (fogState.painting) {
      fogState.painting = false;
      save();
    }

    state.ui.dragMode = 'none';
    state.ui.dragId = null;
    setStatus('Ready');
  });


  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR; const sy = (e.clientY - rect.top) * DPR;

    const before = screenToWorld(sx, sy);
    const factor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(state.view.scale * factor, 0.1, 8);
    state.view.scale = newScale;
    const after = screenToWorld(sx, sy);

    state.view.x += (after.x - before.x) * state.view.scale;
    state.view.y += (after.y - before.y) * state.view.scale;
  }, { passive:false });

  // Context menu (right-click)
  canvas.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR; const sy = (e.clientY - rect.top) * DPR;
    const wpt = screenToWorld(sx, sy);
    const token = hitToken(wpt.x, wpt.y);
    if (!token) { hideMenu(); return; }
    state.tokens.forEach(t=> t.selected = false);
    token.selected = true; updateTokenList();
    showMenu(e.clientX, e.clientY);
  });
  document.addEventListener('click', (e)=>{ if (!ctxMenu.contains(e.target)) hideMenu(); });
  function showMenu(x,y){ ctxMenu.style.left = x+'px'; ctxMenu.style.top = y+'px'; ctxMenu.style.display='block'; }
  function hideMenu(){ ctxMenu.style.display='none'; }

  ctxMenu.addEventListener('click', (e)=>{
    const cmd = e.target.dataset.cmd;
    const t = state.tokens.find(x=>x.selected);
    if(!t) return;
    if (cmd==='rename'){
      const name = prompt('Token name:', t.name || '');
      if (name!==null) t.name = name.trim();
    } else if (cmd==='duplicate'){
      const copy = { ...t, id:'t_'+Math.random().toString(36).slice(2,9), x:t.x+10, y:t.y+10, selected:true };
      state.tokens.forEach(x=>x.selected=false);
      state.tokens.push(copy);
    } else if (cmd==='bring'){
      const i = state.tokens.indexOf(t); if(i>=0){ state.tokens.splice(i,1); state.tokens.push(t); }
    } else if (cmd==='send'){
      const i = state.tokens.indexOf(t); if(i>=0){ state.tokens.splice(i,1); state.tokens.unshift(t); }
    } else if (cmd==='delete'){
      state.tokens = state.tokens.filter(x=>!x.selected);
    }
    hideMenu(); updateTokenList(); save();
  });

  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space') { state.ui.spaceDown = true; canvas.classList.add('dragging'); }
    if(e.key === 'Delete' || e.key === 'Backspace') { deleteSelected(); }
    if(e.key === 'Escape'){ state.tokens.forEach(t=> t.selected = false); updateTokenList(); hideMenu(); }
    if(e.altKey){ state.ui.measuring = true; }
    const t = state.tokens.find(x=>x.selected);
    if(!t) return;
    if(e.key === 'r' || e.key === 'R'){ t.rot = (t.rot||0) + (Math.PI/12); save(); }
    if(e.key === '+'){ t.w*=1.1; t.h*=1.1; save(); }
    if(e.key === '-'){ t.w*=0.9; t.h*=0.9; save(); }
    if(e.key === '['){ const i=state.tokens.indexOf(t); if(i>0){ state.tokens.splice(i,1); state.tokens.splice(i-1,0,t); save(); } }
    if(e.key === ']'){ const i=state.tokens.indexOf(t); if(i>=0 && i<state.tokens.length-1){ state.tokens.splice(i,1); state.tokens.splice(i+1,0,t); save(); } }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code === 'Space'){ state.ui.spaceDown = false; canvas.classList.remove('dragging'); }
    if(!e.altKey && state.ui.measuring && !state.ui.measureToggle){
      state.ui.measuring = false; state.ui.measureStart = null;
    }
    // If Shift released mid-stroke and Brush Mode is OFF, stop fog painting
    if(!e.shiftKey && fogState.painting && !state.ui.brushMode){
      fogState.painting = false; save();
    }
  });

  document.getElementById('mapFile').addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    const dataUrl = await fileToDataUrl(file);
    const img = await loadImage(dataUrl);
    state.map = { imgSrc:dataUrl, img, w: img.naturalWidth, h: img.naturalHeight };
    ensureFogSize();
    // reset map transform when new image loads
    state.mapTransform = { scale:1, x:0, y:0 };
    mapScaleInput.value = 100; mapOffsetXInput.value = 0; mapOffsetYInput.value = 0;
    fctx.clearRect(0,0,fog.width,fog.height);
    fitMap(); save();
  });
  document.getElementById('gridSize').addEventListener('input', (e)=>{ state.grid.size = clamp(parseFloat(e.target.value)||50, 4, 256); save(); });
  document.getElementById('unitsPerCell').addEventListener('input', (e)=>{ state.grid.unitsPerCell = Math.max(1, parseFloat(e.target.value)||5); save(); });
  document.getElementById('gridColor').addEventListener('input', (e)=>{ state.grid.color = e.target.value; save(); });
  document.getElementById('gridAlpha').addEventListener('input', (e)=>{ state.grid.alpha = clamp(parseFloat(e.target.value)||0.35, 0, 1); save(); });
  document.getElementById('showGrid').addEventListener('change', (e)=>{ state.grid.show = e.target.checked; save(); });

  // Map transform inputs (unique names to avoid redeclare)
  const mapScaleInput  = document.getElementById('mapScale');
  const mapOffsetXInput = document.getElementById('mapOffsetX');
  const mapOffsetYInput = document.getElementById('mapOffsetY');
  mapScaleInput.addEventListener('input', (e)=>{ state.mapTransform.scale = clamp((parseFloat(e.target.value)||100)/100, 0.1, 4); save(); });
  mapOffsetXInput.addEventListener('input', (e)=>{ state.mapTransform.x = parseFloat(e.target.value)||0; save(); });
  mapOffsetYInput.addEventListener('input', (e)=>{ state.mapTransform.y = parseFloat(e.target.value)||0; save(); });
  document.getElementById('resetMapTransform').addEventListener('click', ()=>{
    state.mapTransform = { scale:1, x:0, y:0 }; mapScaleInput.value = 100; mapOffsetXInput.value = 0; mapOffsetYInput.value = 0; save();
  });

  // Grid alignment inputs (unique names)
  const gridOffsetXEl = document.getElementById('gridOffsetX');
  const gridOffsetYEl = document.getElementById('gridOffsetY');
  gridOffsetXEl.addEventListener('input', (e)=>{ state.grid.offsetX = parseFloat(e.target.value)||0; save(); });
  gridOffsetYEl.addEventListener('input', (e)=>{ state.grid.offsetY = parseFloat(e.target.value)||0; save(); });

  const calibCellsEl = document.getElementById('calibCells');
  const calibStatusEl = document.getElementById('calibStatus');
  document.getElementById('startCalibrate').addEventListener('click', ()=>{
    state.ui.tool = 'calibrate'; state.ui.calib = { p1:null, p2:null }; calibStatusEl.textContent = 'Click first grid intersection';
  });
  document.getElementById('pickGridOrigin').addEventListener('click', ()=>{
    state.ui.tool = 'pickOrigin'; calibStatusEl.textContent = 'Click the grid intersection to become (0,0)';
  });
  document.getElementById('snapOriginToMap').addEventListener('click', ()=>{
    state.ui.tool = 'snapOrigin'; calibStatusEl.textContent = 'Click a grid intersection on the map';
  });

  document.getElementById('centerMap').addEventListener('click', centerMap);
  document.getElementById('fitMap').addEventListener('click', fitMap);
  document.getElementById('clearMap').addEventListener('click', ()=>{
    state.map = { imgSrc:'', img:null, w:0, h:0 };
    ensureFogSize();
    save();
  });

  // Token actions
  document.getElementById('addToken').addEventListener('click', addTokenFromInputs);
  document.getElementById('deleteSelected').addEventListener('click', deleteSelected);

  // Fog controls
  document.getElementById('toggleFog').addEventListener('click', ()=>{
    fogState.enabled = !fogState.enabled;
    setFogUI(fogState.enabled);
    if (fogState.enabled) ensureFogSize();
    setStatus(fogState.enabled ? 'Fog enabled' : 'Fog disabled');
    save();
  });
  document.getElementById('fogReveal').addEventListener('click', ()=>{ fogState.mode='reveal'; setFogUI(true); });
  document.getElementById('fogCover').addEventListener('click', ()=>{ fogState.mode='cover'; setFogUI(true); });
  document.getElementById('fogBrush').addEventListener('input', (e)=>{ fogState.brush = Math.max(5, Math.min(400, parseFloat(e.target.value)||80)); });
  document.getElementById('fogClear').addEventListener('click', ()=>{ fctx.clearRect(0,0,fog.width,fog.height); save(); });

  // NEW: Brush Mode / Measure toggles (mobile-friendly)
  const fogBrushModeBtn = document.getElementById('fogBrushMode');
  fogBrushModeBtn.addEventListener('click', (e)=>{
    state.ui.brushMode = !state.ui.brushMode;
    e.currentTarget.classList.toggle('active', state.ui.brushMode);
    e.currentTarget.setAttribute('aria-pressed', String(state.ui.brushMode));
    setStatus(state.ui.brushMode ? 'Brush mode ON' : 'Brush mode OFF');
  });
  const measureToggleBtn = document.getElementById('measureToggle');
  measureToggleBtn.addEventListener('click', (e)=>{
    state.ui.measureToggle = !state.ui.measureToggle;
    e.currentTarget.classList.toggle('active', state.ui.measureToggle);
    e.currentTarget.setAttribute('aria-pressed', String(state.ui.measureToggle));
    state.ui.measuring = state.ui.measureToggle;
    if(!state.ui.measureToggle){ state.ui.measureStart = null; }
    setStatus(state.ui.measureToggle ? 'Measure mode ON' : 'Measure mode OFF');
  });

  // Presets
  document.getElementById('addPreset').addEventListener('click', addTokenFromPreset);
  loadTokenManifest().then(buildPresetDropdown);

  // Export / Import
  document.getElementById('exportJson').addEventListener('click', ()=>{
    const payload = localStorage.getItem(STORAGE_KEY) || JSON.stringify({});
    const blob = new Blob([payload], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `battlemap_${new Date().toISOString()}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });
  document.getElementById('importJsonFile').addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      // restore core state
      Object.assign(state.grid, data.grid||{});
      Object.assign(state.view, data.view||{});
      Object.assign(state.mapTransform, data.mapTransform||{});
      state.tokens = (data.tokens || []).map(t => ({
        ...t,
        img: null,
        selected: !!t.selected,
        rot: typeof t.rot === 'number' ? t.rot : 0
      }));

      // Restore fog settings if present
      if (data.fogState) {
        fogState.enabled = !!data.fogState.enabled;
        fogState.mode = data.fogState.mode || fogState.mode;
        fogState.brush = typeof data.fogState.brush === 'number'
          ? data.fogState.brush
          : fogState.brush;
        setFogUI(fogState.enabled);
        document.getElementById('fogBrush').value = fogState.brush;
      }

      if (data.map?.imgSrc) {
        const img = await loadImage(data.map.imgSrc);
        state.map = { imgSrc: data.map.imgSrc, img, w: img.naturalWidth, h: img.naturalHeight };
        ensureFogSize();
      } else {
        state.map = { imgSrc:'', img:null, w:0, h:0 };
        ensureFogSize();
      }

      // fog bitmap
      fctx.clearRect(0,0,fog.width,fog.height);
      if (data.fog) await drawDataUrlToCanvas(data.fog, fog);

      // load token images
      await Promise.all(state.tokens.map(async t => {
        t.img = await loadImage(t.imgSrc);
      }));

      save();
      setStatus('Session imported');
    } catch(err) {
      console.warn(err);
      alert('Import failed: invalid or incompatible file.');
    }
  });

  // Reset-all
  document.getElementById('resetAll').addEventListener('click', ()=>{
    localStorage.removeItem(STORAGE_KEY);
    
    Object.assign(state, {
      map: { imgSrc:'', img:null, w:0, h:0 },
      mapTransform: { scale:1, x:0, y:0 },
      grid: { size:50, unitsPerCell:5, color:'#6aa5ff', alpha:0.35, show:true, offsetX:0, offsetY:0 },
      view: { x:0, y:0, scale:1 },
      tokens: [],
      ui: {
        dragMode: 'none', dragId: null, dragOffset:{x:0,y:0},
        spaceDown:false, tool:'none',
        calib:{p1:null,p2:null},
        measuring:false, measureStart:null,
        brushMode:false, measureToggle:false
      }
    });
  
    // Reset fog state + bitmap
    fogState.enabled = false;
    fogState.mode = 'reveal';
    fogState.brush = 80;
    setFogUI(false);
    fctx.clearRect(0,0,fog.width,fog.height);
  
    updateTokenList();
    setStatus('Session reset');
  });

  function fogDot(ix, iy) {
    const r = fogState.brush * 0.5; // base brush in image px
    if (!fog.width || !fog.height) return;
    if (fogState.mode === 'reveal') {
      fctx.globalCompositeOperation = 'destination-out'; // erase (reveal)
      fctx.beginPath(); fctx.arc(ix, iy, r, 0, Math.PI*2); fctx.fill();
    } else {
      fctx.globalCompositeOperation = 'source-over'; // paint black (cover)
      fctx.fillStyle = 'rgba(0,0,0,1)';
      fctx.beginPath(); fctx.arc(ix, iy, r, 0, Math.PI*2); fctx.fill();
    }
  }

  function addTokenFromInputs(){
    const fileInput = document.getElementById('tokenFile');
    const nameInput = document.getElementById('tokenName');
    const cells = parseFloat(document.getElementById('tokenCells').value) || 1;
    const file = fileInput.files?.[0];
    if(!file){ alert('Choose a token image first, or use the Presets section.'); return; }
    fileToDataUrl(file).then(src=> loadImage(src).then(img=>{
      placeToken(nameInput.value || file.name, src, img, cells);
    }));
  }
  function addTokenFromPreset(){
    const opt = tokenPresetEl.options[tokenPresetEl.selectedIndex];
    const src = opt?.value || '';
    const name = opt?.dataset?.name || opt?.textContent || '';
    if(!src){ alert('Select a preset token first.'); return; }
    const cells = parseFloat(document.getElementById('tokenCells').value) || 1;
    getCachedImage(src).then(img=> placeToken(name, src, img, cells));
  }
  function placeToken(name, src, img, cells){
    const size = state.grid.size * cells;
    const center = screenToWorld(canvas.width/2, canvas.height/2);
    const token = {
      id: 't_'+Math.random().toString(36).slice(2,9),
      name: name || 'Token',
      imgSrc: src,
      img,
      x: center.x - size/2,
      y: center.y - size/2,
      w: size,
      h: size,
      rot: 0,
      selected: true
    };
    state.tokens.forEach(t=> t.selected=false);
    state.tokens.push(token);
    updateTokenList(); save();
    setStatus(`Added ${token.name}`);
  }

  function deleteSelected(){
    const before = state.tokens.length;
    state.tokens = state.tokens.filter(t=> !t.selected);
    if(state.tokens.length !== before){ updateTokenList(); save(); setStatus('Deleted selected tokens'); }
  }

  function updateTokenList(){
    tokenListEl.innerHTML = '';
    for(const t of state.tokens){
      const el = document.createElement('button');
      el.className = 'pill';
      el.textContent = t.name || t.id;
      if(t.selected) el.style.outline = '2px solid var(--accent)';
      el.addEventListener('click', ()=>{ state.tokens.forEach(x=>x.selected=false); t.selected=true; save(); updateTokenList(); });
      tokenListEl.appendChild(el);
    }
  }

  function fileToDataUrl(file){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // ---- Long-press context menu for touch ----
  let lpTimer = null;
  canvas.addEventListener('pointerdown', (e) => {
    if (e.pointerType === 'touch') {
      const startX = e.clientX, startY = e.clientY;
      lpTimer = setTimeout(() => {
        const rect = canvas.getBoundingClientRect();
        const sx = (startX - rect.left) * DPR, sy = (startY - rect.top) * DPR;
        const wpt = screenToWorld(sx, sy);
        const token = hitToken(wpt.x, wpt.y);
        if (token) {
          state.tokens.forEach(t=> t.selected=false);
          token.selected = true; updateTokenList();
          showMenu(startX, startY);
        }
      }, 500);
    }
  }, { passive: true });

  ['pointermove','pointerup','pointercancel'].forEach(ev =>
    canvas.addEventListener(ev, () => { if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; } }, { passive: true })
  );

  // Prevent browser gestures from stealing interaction on canvas while dragging
  canvas.addEventListener('touchmove', (e) => {
    if (state.ui.dragMode !== 'none' || fogState.painting) e.preventDefault();
  }, { passive: false });

  // Boot
  // Hook brush/measure buttons initial state to UI
  document.getElementById('fogBrushMode').classList.toggle('active', state.ui.brushMode);
  document.getElementById('fogBrushMode').setAttribute('aria-pressed', String(state.ui.brushMode));
  document.getElementById('measureToggle').classList.toggle('active', state.ui.measureToggle);
  document.getElementById('measureToggle').setAttribute('aria-pressed', String(state.ui.measureToggle));

  load();
  updateTokenList();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>